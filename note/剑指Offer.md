## 剑指offer

| #           | title                                    | solution | tag  | frequency |
| ----------- | ---------------------------------------- | -------- | ---- | --------- |
| 面试题03       | [数组中重复的数字 LCOF](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof) |          |      |           |
| 面试题04       | [二维数组中的查找 LCOF](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof) |          |      |           |
| 面试题05       | [替换空格 LCOF](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof) |          |      |           |
| 面试题06       | [从尾到头打印链表 LCOF](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof) |          |      |           |
| 面试题07       | [重建二叉树 LCOF](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof) |          |      |           |
| 面试题09       | [用两个栈实现队列 LCOF](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof) |          |      |           |
| 面试题10- I    | [斐波那契数列 LCOF](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof) |          |      |           |
| 面试题10- II   | [青蛙跳台阶问题 LCOF](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof) |          |      |           |
| 面试题11       | [旋转数组的最小数字 LCOF](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof) |          |      |           |
| 面试题12       | [矩阵中的路径 LCOF](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof) |          |      |           |
| 面试题13       | [机器人的运动范围 LCOF](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof) |          |      |           |
| 面试题14- I    | [剪绳子 LCOF](https://leetcode-cn.com/problems/jian-sheng-zi-lcof) |          |      |           |
| 面试题14- II   | [剪绳子 II LCOF](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof) |          |      |           |
| 面试题15       | [二进制中1的个数 LCOF](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof) |          |      |           |
| 面试题16       | [数值的整数次方 LCOF](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof) |          |      |           |
| 面试题17       | [打印从1到最大的n位数 LCOF](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof) |          |      |           |
| 面试题18       | [删除链表的节点 LCOF](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof) |          |      |           |
| 面试题19       | [正则表达式匹配 LCOF](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof) |          |      |           |
| 面试题20       | [表示数值的字符串 LCOF](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof) |          |      |           |
| 面试题21       | [调整数组顺序使奇数位于偶数前面 LCOF](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof) |          |      |           |
| 面试题22       | [链表中倒数第k个节点 LCOF](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof) |          |      |           |
| 面试题24       | [反转链表 LCOF](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof) |          |      |           |
| 面试题25       | [合并两个排序的链表 LCOF](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof) |          |      |           |
| 面试题26       | [树的子结构 LCOF](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof) |          |      |           |
| 面试题27       | [二叉树的镜像 LCOF](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof) |          |      |           |
| 面试题28       | [对称的二叉树 LCOF](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof) |          |      |           |
| 面试题29       | [顺时针打印矩阵 LCOF](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof) |          |      |           |
| 面试题30       | [包含min函数的栈 LCOF](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof) |          |      |           |
| 面试题31       | [栈的压入、弹出序列 LCOF](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof) |          |      |           |
| 面试题32 - I   | [从上到下打印二叉树 LCOF](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof) |          |      |           |
| 面试题32 - II  | [从上到下打印二叉树 II LCOF](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof) |          |      |           |
| 面试题32 - III | [从上到下打印二叉树 III LCOF](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof) |          |      |           |
| 面试题33       | [二叉搜索树的后序遍历序列 LCOF](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof) |          |      |           |
| 面试题34       | [二叉树中和为某一值的路径 LCOF](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof) |          |      |           |
| 面试题35       | [复杂链表的复制 LCOF](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof) |          |      |           |
| 面试题36       | [二叉搜索树与双向链表 LCOF](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof) |          |      |           |
| 面试题37       | [序列化二叉树 LCOF](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof) |          |      |           |
| 面试题38       | [字符串的排列 LCOF](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof) |          |      |           |
| 面试题39       | [数组中出现次数超过一半的数字 LCOF](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof) |          |      |           |
| 面试题40       | [最小的k个数 LCOF](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof) |          |      |           |
| 面试题41       | [数据流中的中位数 LCOF](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof) |          |      |           |
| 面试题42       | [连续子数组的最大和 LCOF](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof) |          |      |           |
| 面试题43       | [1～n整数中1出现的次数 LCOF](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof) |          |      |           |
| 面试题44       | [数字序列中某一位的数字 LCOF](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof) |          |      |           |
| 面试题45       | [把数组排成最小的数 LCOF](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof) |          |      |           |
| 面试题46       | [把数字翻译成字符串 LCOF](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof) |          |      |           |
| 面试题47       | [礼物的最大价值 LCOF](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof) |          |      |           |
| 面试题48       | [最长不含重复字符的子字符串 LCOF](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof) |          |      |           |
| 面试题49       | [丑数 LCOF](https://leetcode-cn.com/problems/chou-shu-lcof) |          |      |           |
| 面试题50       | [第一个只出现一次的字符 LCOF](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof) |          |      |           |
| 面试题51       | [数组中的逆序对 LCOF](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof) |          |      |           |
| 面试题52       | [两个链表的第一个公共节点 LCOF](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof) |          |      |           |
| 面试题53 - I   | [在排序数组中查找数字 LCOF](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof) |          |      |           |
| 面试题53 - II  | [缺失的数字 LCOF](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof) |          |      |           |
| 面试题54       | [二叉搜索树的第k大节点 LCOF](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof) |          |      |           |
| 面试题55 - I   | [二叉树的深度 LCOF](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof) |          |      |           |
| 面试题55 - II  | [平衡二叉树 LCOF](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof) |          |      |           |
| 面试题56 - I   | [数组中数字出现的次数 LCOF](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof) |          |      |           |
| 面试题56 - II  | [数组中数字出现的次数 II LCOF](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof) |          |      |           |
| 面试题57       | [和为s的两个数字 LCOF](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof) |          |      |           |
| 面试题57 - II  | [和为s的连续正数序列 LCOF](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof) |          |      |           |
| 面试题58 - I   | [翻转单词顺序 LCOF](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof) |          |      |           |
| 面试题58 - II  | [左旋转字符串 LCOF](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof) |          |      |           |
| 面试题59 - I   | [滑动窗口的最大值 LCOF](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof) |          |      |           |
| 面试题59 - II  | [队列的最大值 LCOF](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof) |          |      |           |
| 面试题60       | [n个骰子的点数 LCOF](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof) |          |      |           |
| 面试题61       | [扑克牌中的顺子 LCOF](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof) |          |      |           |
| 面试题62       | [圆圈中最后剩下的数字 LCOF](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof) |          |      |           |
| 面试题63       | [股票的最大利润 LCOF](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof) |          |      |           |
| 面试题64       | [求1+2+…+n LCOF](https://leetcode-cn.com/problems/qiu-12n-lcof) |          |      |           |
| 面试题65       | [不用加减乘除做加法 LCOF](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof) |          |      |           |
| 面试题66       | [构建乘积数组 LCOF](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof) |          |      |           |
| 面试题67       | [把字符串转换成整数 LCOF](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof) |          |      |           |
| 面试题68 - I   | [二叉搜索树的最近公共祖先 LCOF](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof) |          |      |           |
| 面试题68 - II  | [二叉树的最近公共祖先 LCOF](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof) |          |      |           |



## 回溯

### [面试题13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

#### 版本1
```java
class Solution {
    private int[] x_axis = {-1, 1, 0, 0};
    private int[] y_axis = {0 ,0, -1, 1};
    private int[][] visited;
    private int count = 0;
    private int M, N, K;
    public int movingCount(int m, int n, int k) {
        visited = new int[m][n];
        M = m;
        N = n;
        K = k;
        dfs(0, 0);
        return count;
    }

    private void dfs(int x, int y) {
        visited[x][y] = 1;
        count++;
        for(int i = 0; i < 4; i++) {
            int next_x = x + x_axis[i];
            int next_y = y + y_axis[i];
            boolean inBoundary = next_x >= 0 && next_x < M && next_y >= 0 && next_y < N;
            if(inBoundary && visited[next_x][next_y] == 0 && calculate(next_x, next_y) <= K) {
                dfs(next_x, next_y);
            }
        }
    }

    // 计算行坐标和列坐标的数位之和
    private int calculate(int x, int y) {
        int sum = 0;
        while(x > 0) {
            sum += x % 10;
            x /= 10;
        }
        while(y > 0) {
            sum += y % 10;
            y /= 10;
        }
        return sum;
    }
}
```

#### 版本2
```java
class Solution {
    public int movingCount(int m, int n, int k) {
        boolean[][] visited = new boolean[m][n];
        return dfs(0, 0, k, visited);
    }

    private int dfs(int x, int y, int k, boolean[][] visited) {
        boolean inBoundary = x >= 0 && x < visited.length && y >= 0 && y < visited[0].length;
        if(!inBoundary || visited[x][y] || calculate(x, y) > k) {
            return 0;
        }else {
            visited[x][y] = true;
            return  1 + 
                    dfs(x-1, y, k, visited) +
                    dfs(x+1, y, k, visited) +
                    dfs(x, y-1, k, visited) +
                    dfs(x, y+1, k, visited);
        }
    }

    // 计算行坐标和列坐标的数位之和
    private int calculate(int x, int y) {
        int sum = 0;
        while(x > 0) {
            sum += x % 10;
            x /= 10;
        }
        while(y > 0) {
            sum += y % 10;
            y /= 10;
        }
        return sum;
    }
}
```



## 树

### [面试题07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return helper(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);
    }
    private TreeNode helper(int[] preorder, int pl, int pr, int[] inorder, int il, int ir) {
        if(pl > pr) return null; // 边界条件
        int rootVal = preorder[pl];
        TreeNode root = new TreeNode(rootVal);
        int pos = il; // 中序序列中根节点的索引
        while(inorder[pos] != rootVal) {
            pos++;
        }
        int count = pos - il; // 左子树的节点个数
        root.left = helper(preorder, pl+1, pl+count, inorder, il, pos-1);
        root.right = helper(preorder, pl+count+1, pr, inorder, pos+1, ir);
        return root;
    }
}
```



## 链表

35题

```java
class Solution {
    public Node copyRandomList(Node head) {
        // 复制节点: A->A'->B->B'->C->C'
        Node curr = head;
        while(curr != null) {
            Node copy = new Node(curr.val);
            copy.next = curr.next;
            curr.next = copy;
            curr = copy.next;
        }
        // 复制random指针
        curr = head;
        while(curr != null && curr.next != null) {
            curr.next.random = curr.random == null ? null : curr.random.next;
            curr = curr.next.next;
        }
        // 分离节点
        Node dummy = new Node(-1);
        Node prev = dummy;
        curr = head;
        while(curr != null) {
            prev.next = curr.next;
            curr.next = curr.next.next;
            prev = prev.next;
            curr = curr.next;
        }
        return dummy.next;
    }
}
```



25题

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(-1);
        ListNode prev = dummy;
        while(l1 != null && l2 != null) {
            if(l1.val <= l2.val) {
                prev.next = l1;
                l1 = l1.next;
            }else {
                prev.next = l2;
                l2 = l2.next;
            }
            prev = prev.next;
        }
        if(l1 != null) {
            prev.next = l1;
        }
        if(l2 != null) {
            prev.next = l2;
        }
        return dummy.next;
    }
}
```



24题 翻转链表

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null, curr = head;
        while(curr != null) {
            ListNode t = curr;
            curr = curr.next;
            t.next = prev;
            prev = t;
        }
        return prev;
    }
}
```



22题 链表中倒数第k个节点

```java
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode low = head, high = head;
        for(int i = 1; i < k; i++) {
            high = high.next;
        }
        while(high.next != null) {
            low = low.next;
            high = high.next;
        }
        return low;
    }
}
```



18题 删除链表的节点

```java
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode prev = dummy, curr = head;
        while(curr != null) {
            if(curr.val == val) {
                prev.next = curr.next;
                break;
            }
            prev = curr;
            curr = curr.next;
        }
        return dummy.next;
    }
}
```



6题 逆序打印链表

```java
class Solution {
    public int[] reversePrint(ListNode head) {
        List<Integer> list = new ArrayList<>();
        helper(head, list);
        int[] res = new int[list.size()];
        for(int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);
        }
        return res;
    }

    private void helper(ListNode curr, List<Integer> list) {
        if(curr == null) return;
        helper(curr.next, list);
        list.add(curr.val); 
    }
}
```



## 队列、栈



### [面试题30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

```java
class MinStack {
    LinkedList<Integer> data;
    LinkedList<Integer> helper; 
    public MinStack() {
        data = new LinkedList<>();
        helper = new LinkedList<>();
    }
    
    public void push(int x) {
        data.addFirst(x); // 注意数据的插入要用头插法~
        if(helper.isEmpty() || x <= helper.peek()) {
            helper.addFirst(x);
        }
    }
    
    public void pop() {
        if(!data.isEmpty()) {
            int peek = data.poll();
            if(helper.peek() == peek) {
                helper.poll();
            }
        }else {
            throw new RuntimeException("stack empty.");
        }
    }
    
    public int top() {
        if(!data.isEmpty()) {
            return data.peek();
        }else {
            throw new RuntimeException("stack empty.");
        }
    }
    
    public int min() {
        if(!helper.isEmpty()) {
            return helper.peek();
        }else {
            throw new RuntimeException("stack empty.");
        }
    }
}
```

评注：使用LinkedList作为栈，比直接使用Stack会更快！注意数据的插入要用头插法，即`stack.addFirst(x)`。



### [面试题31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

感觉很简单，但是非常不熟练~
```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        Stack<Integer> s = new Stack<>();
        int i = 0;
        for(int num : pushed) {
            s.add(num);
            while(!s.isEmpty() && s.peek() == popped[i]) {
                s.pop();
                i++;
            }
        }
        // 如果是合法的出栈序列，那么i应该等于poped.length
        return i == popped.length;
    }
}
```



## 数组

### [面试题03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

#### 方法1：采用哈希表
```java
class Solution {
    // 时间复杂度：O(n)
    // 空间复杂度：O(n)
    public int findRepeatNumber(int[] nums) {
        int[] map = new int[nums.length];
        int repeatNumber = 0;
        for(int num : nums) {
            map[num]++;
            if(map[num] > 1) {
                repeatNumber = num;
                break;
            }
        }
        return repeatNumber;
    }
}
```

#### 方法2：排序
时间复杂度：O(nlogn)
空间复杂度：O(1)

#### 方法3：原地交换（妙）
```java
class Solution {
    // 时间复杂度：O(n)，均摊时间复杂度
    // 空间复杂度：O(1)
    public int findRepeatNumber(int[] nums) {
        for(int i = 0; i < nums.length; i++) {
            while(i != nums[i]) {
                if(nums[i] == nums[nums[i]]) {
                    return nums[i];
                }
                swap(nums, i, nums[i]);
            }
        }
        return -1; // never happens
    }

    private void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
}
```


#### 方法4：二分法，抽屉原理

```java

```



### [面试题04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

示例，现有矩阵 matrix 如下：

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

从下面这个角度去思考，不就是一个递增序列么？

![image-20200606133649450](../img/jianzhioffer04.png)

初始化为左下角的位置：

* 如果目标值比当前位置的值大，说明在该位置的右侧；
* 如果目标值比当前位置的值小，说明在该位置的上侧；

时间复杂度：O(n+m)；空间复杂度：O(1)

```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        int n = matrix.length;
        if(n == 0) return false;
        int m = matrix[0].length;
        if(m == 0) return false;

        int row = n-1, col = 0;
        while(row >= 0 && col < m) {
            if(matrix[row][col] == target) return true;
            else if(matrix[row][col] < target) col++;
            else  row--;
        }
        return false;
    }
}
```

 

### [面试题05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

```java
class Solution {
    public String replaceSpace(String s) {
        StringBuilder sb = new StringBuilder();
        for(int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if(ch != ' ') sb.append(ch);
            else sb.append("%20");
        }
        return sb.toString();
    }
}
```

Or

```java
class Solution {
    public String replaceSpace(String s) {
        return s.replace(" ", "%20");
    }
}
```



### [面试题11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/) (☆)

二分思想

```java
class Solution {
    public int minArray(int[] nums) {
        int left = 0, right = nums.length-1;
        while (left < right){
            int mid = (right - left) / 2 + left;
            // [left, mid] 是前半个有序区间，最小值位于[mid+1, right]内
            if(nums[mid] > nums[right]) left = mid + 1;
            // [mid, right] 是后半个有序区间，最小值位于[left, mid]内
            else if(nums[mid] < nums[right])
                right = mid;
            else
                right--;
        }
        return nums[right];
    }
}
```

回顾

https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/

https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/



### [面试题21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

双指针法

```java
class Solution {
    public int[] exchange(int[] nums) {
        int left = 0, right = nums.length - 1;
        while(left < right) {
            while(left < right && nums[left] % 2 == 1) left++; // left 指向偶数
            while(left < right && nums[right] % 2 == 0) right--; // right 指向奇数
            // swap 
            int t = nums[left];
            nums[left] = nums[right];
            nums[right] = t;
        }
        return nums;
    }
}
```



## 动态规划

### [面试题10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

方法1：递归（超时）
```java
class Solution {
    public int fib(int n) {
        if(n == 0 || n == 1) return n;
        return fib(n-1) + fib(n-2);
    }
}
```

方法2：递归+备忘录 
```java
class Solution {
    Map<Integer, Integer> map = new HashMap<>();
    int MOD = 1000000007; // 题目要求要除余
    public int fib(int n) {
        if(n == 0 || n == 1) return n;
        if(map.get(n) != null) return map.get(n);
        int v = (fib(n-1) + fib(n-2)) % MOD;
        map.put(n, v);
        return v;
    }
}
```

方法3：动态规划（也就是把递归翻译成迭代）
时间复杂度：O(n)
空间复杂度：O(n)

```java
class Solution {
    int MOD = 1000000007;
    public int fib(int n) {
        if(n == 0 || n == 1) return n;
        int[] dp = new int[n+1];
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2; i <= n; i++) {
            dp[i] = (dp[i-1] + dp[i-2]) % MOD;
        }
        return dp[n];
    }
}
```

方法4：方法3的优化（空间复杂度降至O(1)）
```java
class Solution {
    int MOD = 1000000007;
    public int fib(int n) {
        if(n == 0 || n == 1) return n;
        int res = -1, i2 = 0, i1 = 1;
        for(int i = 2; i <= n; i++) {
            res = (i1 + i2) % MOD;
            i2 = i1;
            i1 = res;
        }
        return res;
    }
}
```



### [面试题10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

同斐波那契数列问题，边界处理稍有不一样。

```java
class Solution {
    int MOD = 1000000007;
    public int numWays(int n) {
        if(n == 0 || n == 1) return 1;
        int res = 0, i2 = 1, i1 = 1;
        for(int i = 2; i <= n; i++) {
            res = (i1 + i2) % MOD;
            i2 = i1;
            i1 = res;
        }
        return res;
    }
}
```



## DFS & BFS





## 位运算

### [面试题15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;
        while(n != 0) {
            count++;
            n = n & (n - 1);
        }
        return count;
    }
}
```











## 数学模拟

### [面试题16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/) (经典)

题目限定了如下范围：

- 底数：-100.0 < *x* < 100.0
- 指数：n 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] 。

评注：本题感觉上很简单，但是要写出鲁棒的代码也不简单，尤其在面试较为紧张的环境下，需要对边界情况好好考虑。



```java
class Solution {
    /*  二分法：原理
        a^n = (a^(n/2)) * (a^(n/2))               ==> 当n为偶数时
            = (a^((n-1)/2)) * (a^((n-1)/2)) * a   ==> 当n为奇数时
    */
    public double myPow(double x, int n) {
        // case 1: 当底数为0，而指数为负数时，即要求计算 1/(0^n)，即被除数为0，这是不合法的
        if(equal(x, 0.0) && n < 0) {
            throw new RuntimeException("Invalid input."); // 被除数为0是不合法的
        }
        // case 2: 当底数为0，而指数n >= 0时，结果均为0
        if(equal(x, 0.0)) {
            return 0.0;
        }
        // case 3: 当指数为1时，结果即为底数本身
        if(n == 1) {
            return x;
        }
        // case 4: 当指数为0时，结果即为1
        if(n == 0) {
            return 1.0;
        }

        boolean isNegative = n < 0;
        // -2147483648 ==> 直接 n 转换成 -n 会溢出，故采用long型
        long N = isNegative ? -1 * (long)n : (long)n;
        double ans = 1.0;
        double curr = x;
        for(long i = N; i > 0; i /= 2) {
            if(i % 2 == 1) {
                ans = ans * curr;
            }
            curr = curr * curr;
            //System.out.println("ans = " + ans + ", curr = " + curr);
        }
        return isNegative ? 1.0 / ans : ans;
    }

    private boolean equal(double a, double b) {
        if(a - b > -0.0000001 && a - b < 0.0000001) return true;
        else return false;
    }
}

/* 考虑不周的case
case 1: x^0 = 1 的情况

case 3:
1.00000
2147483647
超时

解决：x = 1 时特殊处理

case 4:
2.00000
-2147483648    ==> 直接 n 转换成 -n 会溢出
*/
```



## 位运算

