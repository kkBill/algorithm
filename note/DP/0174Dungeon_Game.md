#### [174. Dungeon Game](https://leetcode-cn.com/problems/dungeon-game/)

一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个**正整数**。**如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡**。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。骑士每次只向右或向下移动一步。**编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。**

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。

```
-2 	-3	 3
-5	-10	 1
10	30	-5 
```

分析：本题与62,63,64题类似，思路一脉相承。

##### 状态

令`dp[i][j]`表示从位置`(i,j)`到达终点时需要的最低健康点数。

##### 初始化

这里的初始化相较于前几题，稍稍绕了个弯。

* 若`grid[m-1][n-1] < 0`(不妨令其为-5)，则表示达到该位置时需要消耗5个健康点数，为了保持骑士始终活着，则其健康点数至少为1，因此令`dp[m-1][n-1] = -grid[m-1][n-1]+1 = 5+1 = 6`；
* 若`grid[m-1][n-1] ≥ 0`， 说明在该位置不消耗健康点数，根据题意“骑士的初始健康点数为一个**正整数**”，因此令`dp[m-1][n-1] =1 `。 

##### 状态转移

本题是从后向前遍历的，到达位置`(i,j)`，可以从`(i+1,j)`向上或从`(i,j+1)`向左达到，每到达位置`(i,j)`时，需要消耗掉`-grid[i][j]`个健康点数，因此可以得到：

`dp[i][j] = Math.min(dp[i+1][j], dp[i][j+1]) - grid[i][j];`

但这其实是不严谨的，比如`grid[i][j]`为正值时，可能会出现`dp[i][j] = Math.min(dp[i+1][j],dp[i][j+1])-grid[i][j]`的计算结果为负的情况，因此，还需要增加一个限定条件。即正确的状态转移方程为：

`dp[i][j] =Math.max(1, Math.min(dp[i+1][j], dp[i][j+1]) - grid[i][j]);`

##### 注意点

处理本题的一些边界条件关键在于深刻理解题中的这句话：“骑士的初始健康点数为一个**正整数**。**如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡**”。在写代码的过程中也可以用几个特殊的测试用例验证自己的想法，比如下面这种特殊情况：

```
[[2,1]]
```

代码：

写法1：

```java
class Solution {
    public int calculateMinimumHP(int[][] grid) {
        int m = grid.length;
        if(m == 0) return 0;
        int n = grid[0].length;
        
        int[][] dp = new int[m][n];
        // 令dp[i][j]表示从(i,j)到达终点所需要的最小健康点数
        // 初始化
        if(grid[m-1][n-1] < 0) dp[m-1][n-1] = -grid[m-1][n-1] + 1;
        else dp[m-1][n-1] = 1;
        
        for(int i = m-2; i >= 0; i--) {
            dp[i][n-1] = Math.max(1, dp[i+1][n-1] - grid[i][n-1]);
        }
        
        for(int j = n-2; j >= 0; j--) {
            dp[m-1][j] = Math.max(1, dp[m-1][j+1] - grid[m-1][j]);
        }
        // 状态转移
        for(int i = m-2; i >= 0; i--) {
            for(int j = n-2; j >= 0; j--) {
                dp[i][j] =Math.max(1, Math.min(dp[i+1][j], dp[i][j+1]) - grid[i][j]);
            }
        }
        return dp[0][0];
    }
}
```

写法2：

```java
class Solution {
    /*
    整体反向思考
    状态定义：
        dp[i][j]表示骑士为了能够继续进行下去，在(i,j)处与恶魔斗争之前需要保证的最低健康值
        特别要注意，这里强调的是骑士在(i,j)处”执行动作之前“的最低健康值，明确这一点非常重要！
    初始化：
        若grid[m-1][n-1] <= 0，则dp[m-1][n-1] = -grid[m-1][n-1] + 1
        若grid[m-1][n-1] > 0，则dp[m-1][n-1] = 1

    状态转移：
        对于处于(i,j)的骑士，可能向下移动”(i,j)->(i+1,j)“，也可能向右移动”(i,j)->(i,j+1)“
        dp[i][j] = min(dp[i+1][j], dp[i][j+1]) - grid[i][j]
           ||
           \/
        dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - grid[i][j]);
    */
    public int calculateMinimumHP(int[][] grid) {
        int m = grid.length;
        if(m == 0) return 0;
        int n = grid[0].length;
        int[][] dp = new int[m+1][n+1];
        // 初始化(添加边界)
        for(int i = 0; i < n+1; i++) dp[m][i] = Integer.MAX_VALUE;
        for(int i = 0; i < m+1; i++) dp[i][n] = Integer.MAX_VALUE;
        // 状态转移
        for(int i = m-1; i >= 0; i--) {
            for(int j = n-1; j >= 0; j--) {
                if(i == m-1 && j == n-1) {
                    dp[m-1][n-1] = grid[m-1][n-1] <= 0 ? -grid[m-1][n-1] + 1 : 1;
                }else {
                    dp[i][j] = Math.max(1, Math.min(dp[i+1][j], dp[i][j+1]) - grid[i][j]);
                }
            }
        }
        return dp[0][0];
    }
}
```

