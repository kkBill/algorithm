## 动态规划

### 什么是动态规划

动态规划（Dynamic Programming，DP）是一种用来解决一类**最优化问题**的算法思想。简单的说，动态规划将一个问题分解成若干个子问题，通过综合子问题的最优解来获得原问题的最优解。但是，**动态规划会将求解过的子问题的结果记录下来**，以便下次碰到同样的子问题时可以直接返回结果，从而避免重复计算。不过这只是动态规划用来提高效率的方法，并不是动态规划思想的核心。我觉得DP的核心是寻找状态和确定状态转移方程，这个在后面结合例题说明。

我们可以采用递归或迭代的方式来实现动态规划，其中动态规划的递归写法又被称为“记忆化搜索”。



### 动态规划的递归写法

通过递归写法来了解如何记录**子问题**的结果。

先从简单的例子开始说起，以斐波那契数列为例，斐波那契数列的定义为F(0)=1, F(1)=1, F(n)=F(n-1)+F(n-2)，很快能按照递归的思想写出如下代码：

```java
int F(int n){
	if(n==0 || n==1) return 1;
	else return F(n-1)+F(n-2);
}
```

但是，我们知道，简单的递归会存在大量的重复计算，其时间复杂度会高达O(2^n)，也就是对任意 n ，都会计算F(n-1) 和 F(n-2) 这两个分支。为此，我们可以开一个一维数组 dp[]，**用于保存中间计算结果**，dp[n] 记录 F(n) 的结果，并用dp[n] = -1表示 F(n) 当前还没有被计算过。于是，改进上述递归代码，变成如下：

```java
int F(int n){
	if(n==0 || n==1) return 1;   //递归边界
	if(dp[n] != -1) return dp[n];//已经计算过，直接返回结果，不再重复计算
	else{
    	dp[n] = F(n-1)+F(n-2);   //计算F(n)，并保存至dp[n]中
    	return dp[n];
	}
}
```

通过把中间计算结果记录下来，当需要再次计算该值时，则可以直接返回，从而避免了大量的重复计算。由于“记住了中间结果”，这种方法也被称为“**记忆化搜索**”。通过记忆化搜索，把时间复杂度从O(2^n)降为了O(n)。以计算 F(5) 为例，两者的递归图如下：

![斐波那契](../../img/Fibonacci.jpg)

通过上面的例子引出一个概念：**重叠子问题**（overlapping subproblems）。

**如果一个问题可以被分解为若干个子问题，且这些子问题会重复出现，那么就称这个问题拥有重叠子问题**。对于这种类型的题目，则可以想想是否可以使用动态规划求解。

当然，上面的递归写法也可以改成迭代写法，如下：

```java
int F(int n) {
	if(n==0 || n==1) return 1;
  	int[] dp = new int[n+1];
  	dp[0] = dp[1] = 1;
    for(int i=2; i<=n; i++){
        dp[i] = dp[i-2] + dp[i-1];
    }
    return dp[n];
}
```

还可以更简化一点，把空间复杂度降为O(1)。

```java
public int F(int n) {
     if(n==0 || n==1) return 1;
     int pre1 = 1, pre2 = 1, cur = 0;
     for(int i=2;i<=n;i++){
         cur = pre2 + pre1;
         pre2 = pre1;
         pre1 = cur;
     }
     return cur;
}
```



### 动态规划的迭代写法

以经典的数塔问题为例。即[120. Triangle](https://leetcode-cn.com/problems/triangle/)。

问题描述：

如下图所示，将一些数字排成塔的形状，其中第1层有1个数字，第2层有2个数字，第n层有n个数字。现在要从第1层走到第n层，每向下一层时只能选择与其连接的两个数字的其中之一。找出一条路径，使得该路径上的数字之和最大。

![Image result for 数塔问题](https://tse4-mm.cn.bing.net/th/id/OIP.12AIdtEKQnRlIVPkjybL3wAAAA?w=273&h=160&c=7&o=5&dpr=1.1&pid=1.7)

分析：

假设现在从 9->12->6 来到了 6，并枚举从 6 出发到达最底层的所有路径。之后，当按 9->15->6 的路线再次来到 6 时，我们显然不希望再进行重复计算，于是，我们想到，当第一次枚举从 6 出发到达最底层的所有路径时，就应该把所获得的最大路径和记录下来，这样当再次访问到数字 6 时，就可以直接获取这个最大值，而不需要再次进行计算。

于是，我们令 `dp[i][j]`  表示第 i 层的第 j 个数字到达最底层的最大路径和，比如 `dp[3][2]` 即表示数字 6 达到最底层的最大路径和。在定义了这个数组之后，显然，`dp[1][1]` 就是第 1 层到达最底层的最大路径和，也就是我们所要求得的解。那么，如何计算出 `dp[1][1]` 呢？

我们发现，对于数塔中的任意一个数字（假设它是第 i 层第 j 个数字，记为 `t(i, j)` ），那么它到最底层的最大路径和仅与 `t(i+1, j)` 和 `t(i+1, j+1)` 这两个数字达到最底层的最大路径和有关，也就是：

```shell
dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + t[i][j]
```

我们把 `dp[i][j]` 称为问题的**状态**，而把上面的式子称为**状态转移方程**，它把状态 `dp[i][j]` 转移为 `dp[i+1][j] 和 dp[i+1][j+1]` ，也就是把第 i 层的状态推到了第 i+1 层的状态，逐层下推，由此也可以很容易想到，状态的**边界**就是到达最底层的时候，数塔最后一层的dp值等于其元素本身，即

```shell
dp[n][j] = t[n][j] (1≤j≤n)
```

我们**把这种能直接确定其结果的部分称为边界，而动态规划的迭代写法总是从这些边界出发，并通过状态转移方程扩散至整个dp数组**。

根据上述的分析，迭代写法如下：（注意下标是从0开始的）

```java
public class DigitTower {
    private static int[][] tower = {{9}, {12, 15}, {10, 6, 8}, {2, 18, 9, 5}, {19, 7, 10, 4, 16}};
    public static void main(String[] args) {
        int n = tower.length;
        int[][] dp = new int[n][n];
        // 初始化边界
        for (int j = 0; j < n; j++) {
            dp[n - 1][j] = tower[n - 1][j];
        }
        // 从倒数第2层开始自底向上，递推求解
        for (int i = n - 2; i >= 0; i--) {
            for (int j = 0; j < i + 1; j++) {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i + 1][j + 1]) + tower[i][j];
            }
        }
        System.out.println("answer: " + dp[0][0]);
    }
}
```

当然，数塔问题也可以使用递归的方式解决，代码如下：

```java
public class DigitTower {
    private static int[][] tower = {{9}, {12, 15}, {10, 6, 8}, {2, 18, 9, 5}, {19, 7, 10, 4, 16}};
    static int n = tower.length;
    static int[][] dp = new int[n][n];

    // 动态规划的递归写法
    private static int process(int i, int j) {
        if (i == n - 1) return tower[i][j]; // 边界，到达最后一层
        if (dp[i][j] != -1) return dp[i][j];
        else {
            dp[i][j] = Math.max(process(i + 1,j), process(i + 1,j + 1))+ tower[i][j];
            return dp[i][j];
        }
    }

    public static void main(String[] args) {
        // 先标记数组
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], -1);
        }
        System.out.println("answer: " + process(0,0));
    }
}
```

递归和迭代的区别在于：使用迭代方法需要先初始化边界，再自底向上进行更新；而使用递归方法则是自顶向下，即从目标问题开始，将它分解成子问题的组合，指导分解至边界为止。个人的感觉是，迭代法更加的直观、好理解，但**核心就是找出状态和状态转移方程**。

通过数塔这个例子，再引出一个概念：**最优子结构**。

如果一个问题的最优解可以由其子问题的最优解构造出来，那么称这个问题拥有最优子结构。最优子结构**保证**了动态规划中原问题的最优解可以由子问题的最优解推导而来。

需要指出，一个问题必须拥有重叠子问题和最优子结构才能使用动态规划去解决。下面再深入的理解一下这两个概念：

* 分治与动态规划

  分治和动态规划都是将问题分解为子问题，但不同的是，分治法分解出的子问题**并不拥有拥有重叠子问题**，比如在排序算法中的快排和归并，将待排序列分解成左子序列和右子序列，然后将左右序列的结果合并，过程中并不会出现重叠的情况。与之对应的就是前面引入的斐波那契数列的例子，在这个例子中，计算 F(5) 这个问题被分解为计算 F(4) 和 F(3) ，但是在计算 F(4) 和 F(3) ，又都会出现 F(3), F(2)等，这就是所谓的重叠。

* 贪心与动态规划

  贪心和动态规划都要求原问题有最优子结构。区别在于：贪心并不等待所有子问题都求解完毕后再选择使用哪一个，而是通过一种“策略”直接选择一个子问题继续求解（这里的“策略”是需要通过归纳法证明的）；而动态规划（不管是采用递归还是迭代法），本质上都是从边界开始向上更新最终得到问题的解，也就是说，它总是会考虑所有的子问题，并选择最优的那一个进行下一步的计算。

